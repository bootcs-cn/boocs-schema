package generator

import (
	"fmt"
	"os"
	"path/filepath"
	"strings"

	"gopkg.in/yaml.v3"
)

// Course represents course.yml structure
type Course struct {
	Slug           string   `yaml:"slug"`
	Name           string   `yaml:"name"`
	Summary        string   `yaml:"summary"`
	Icon           string   `yaml:"icon"`
	Difficulty     string   `yaml:"difficulty"`
	Status         string   `yaml:"status"`
	Languages      []string `yaml:"languages"`
	Tags           []string `yaml:"tags"`
	DefaultTimeout int      `yaml:"defaultTimeout"`
	AccessType     string   `yaml:"accessType"`
	StageOrder     []string `yaml:"stage_order"`
}

// Stage represents stage.yml structure
type Stage struct {
	Slug       string `yaml:"slug"`
	Name       string `yaml:"name"`
	Summary    string `yaml:"summary"`
	Difficulty string `yaml:"difficulty"`
	Category   string `yaml:"category"`
}

// Generator generates documentation from course/stages
type Generator struct {
	dir string
}

// New creates a new Generator
func New(dir string) *Generator {
	return &Generator{dir: dir}
}

// GenerateREADME generates README.md content
func (g *Generator) GenerateREADME() (string, error) {
	// åŠ è½½ course.yml
	course, err := g.loadCourse()
	if err != nil {
		return "", fmt.Errorf("failed to load course.yml: %w", err)
	}

	// åŠ è½½æ‰€æœ‰ stages
	stages, err := g.loadStages(course.StageOrder)
	if err != nil {
		return "", fmt.Errorf("failed to load stages: %w", err)
	}

	// ç”Ÿæˆ README
	return g.render(course, stages), nil
}

func (g *Generator) loadCourse() (*Course, error) {
	data, err := os.ReadFile(filepath.Join(g.dir, "course.yml"))
	if err != nil {
		return nil, err
	}

	var course Course
	if err := yaml.Unmarshal(data, &course); err != nil {
		return nil, err
	}
	return &course, nil
}

func (g *Generator) loadStages(stageOrder []string) ([]*Stage, error) {
	stages := make([]*Stage, 0, len(stageOrder))

	for _, slug := range stageOrder {
		stageFile := filepath.Join(g.dir, "stages", slug, "stage.yml")
		data, err := os.ReadFile(stageFile)
		if err != nil {
			// å¦‚æžœ stage.yml ä¸å­˜åœ¨ï¼Œåˆ›å»ºä¸€ä¸ªæœ€å°çš„ stage
			stages = append(stages, &Stage{
				Slug:       slug,
				Name:       slug,
				Difficulty: "medium",
			})
			continue
		}

		var stage Stage
		if err := yaml.Unmarshal(data, &stage); err != nil {
			return nil, fmt.Errorf("failed to parse %s: %w", stageFile, err)
		}
		stages = append(stages, &stage)
	}

	return stages, nil
}

func (g *Generator) render(course *Course, stages []*Stage) string {
	var sb strings.Builder

	// æ ‡é¢˜
	sb.WriteString(fmt.Sprintf("# %s\n\n", course.Name))

	// ç®€ä»‹
	summary := strings.TrimSpace(course.Summary)
	sb.WriteString(fmt.Sprintf("> %s\n\n", strings.ReplaceAll(summary, "\n", "\n> ")))

	// Badges
	sb.WriteString(g.renderBadges(course))
	sb.WriteString("\n\n")

	// æ ‡ç­¾
	if len(course.Tags) > 0 {
		sb.WriteString(fmt.Sprintf("**æ ‡ç­¾**: %s\n\n", strings.Join(course.Tags, ", ")))
	}

	// Stages è¡¨æ ¼
	sb.WriteString("## Stages\n\n")
	sb.WriteString("| # | Stage | åˆ†ç±» | ç®€ä»‹ | éš¾åº¦ |\n")
	sb.WriteString("|--:|-------|------|------|------|\n")

	for i, stage := range stages {
		difficulty := g.formatDifficulty(stage.Difficulty)
		category := stage.Category
		if category == "" {
			category = "-"
		}
		name := stage.Name
		if name == "" {
			name = stage.Slug
		}
		summary := strings.TrimSpace(stage.Summary)
		// ç§»é™¤æ¢è¡Œ
		summary = strings.ReplaceAll(summary, "\n", " ")
		// æŒ‰å­—ç¬¦ï¼ˆruneï¼‰æˆªæ–­ï¼Œé¿å…ä¸­æ–‡ä¹±ç 
		runes := []rune(summary)
		if len(runes) > 30 {
			summary = string(runes[:27]) + "..."
		}

		sb.WriteString(fmt.Sprintf("| %d | [%s](stages/%s/) | %s | %s | %s |\n",
			i+1, name, stage.Slug, category, summary, difficulty))
	}

	sb.WriteString("\n---\n\n")
	sb.WriteString("*Generated by [schema-tool](https://github.com/bootcs-cn/boocs-schema)*\n")

	return sb.String()
}

func (g *Generator) renderBadges(course *Course) string {
	var badges []string

	// Difficulty badge
	diffColor := map[string]string{
		"easy":   "green",
		"medium": "yellow",
		"hard":   "red",
	}
	color := diffColor[course.Difficulty]
	if color == "" {
		color = "gray"
	}
	badges = append(badges, fmt.Sprintf("![Difficulty](https://img.shields.io/badge/difficulty-%s-%s)", course.Difficulty, color))

	// Status badge
	statusColor := map[string]string{
		"published": "green",
		"beta":      "yellow",
		"draft":     "gray",
		"archived":  "lightgray",
	}
	sColor := statusColor[course.Status]
	if sColor == "" {
		sColor = "gray"
	}
	badges = append(badges, fmt.Sprintf("![Status](https://img.shields.io/badge/status-%s-%s)", course.Status, sColor))

	// Languages badge
	if len(course.Languages) > 0 {
		langs := strings.Join(course.Languages, " | ")
		// URL encode
		langs = strings.ReplaceAll(langs, " ", "%20")
		langs = strings.ReplaceAll(langs, "|", "%7C")
		badges = append(badges, fmt.Sprintf("![Languages](https://img.shields.io/badge/languages-%s-blue)", langs))
	}

	return strings.Join(badges, " ")
}

func (g *Generator) formatDifficulty(diff string) string {
	switch diff {
	case "easy":
		return "ðŸŸ¢ Easy"
	case "medium":
		return "ðŸŸ¡ Medium"
	case "hard":
		return "ðŸ”´ Hard"
	default:
		return "ðŸŸ¡ Medium"
	}
}

// WriteREADME generates and writes README.md to the course directory
func (g *Generator) WriteREADME(outputPath string) error {
	content, err := g.GenerateREADME()
	if err != nil {
		return err
	}

	if outputPath == "" {
		outputPath = filepath.Join(g.dir, "README.md")
	}

	return os.WriteFile(outputPath, []byte(content), 0644)
}
